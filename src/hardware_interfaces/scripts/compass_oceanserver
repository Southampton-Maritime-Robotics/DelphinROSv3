

"""
Driver for pressure transducer to measure depth

keys parameters 
-depth: the raw measurement from the pressure transducer
-depth_calib: the depth filtered for glitches and calibrated with the pitch angle of the AUV
-depth_filt: the depth reading that is filtered by the polynomial-type (PT) filter
-depth_der: the derivative of depth that is determined from the gradient of PT filter

######################################
# TODO 

"""

import rospy
import numpy
import serial
import time
import math
from re import findall
from std_msgs.msg import String
from hardware_interfaces.msg import compass
from hardware_interfaces.msg import depth
from hardware_interfaces.msg import status

global serialPort


    L_sensor    = 1.2   # a location of the depth sensor w.r.t. AUV nose. [m] measured
    L_ref        = 0.65  # a reference point w.r.t. AUV nose [m] approximate
    L_shift     = L_sensor-L_ref # [m]

################################################################
def setUpSerial():
    global serialPort
    serialPort = serial.Serial(port='/dev/usboceanserver', baudrate='115200', timeout=0.01) # may need to change timeout if having issues!
    serialPort.bytesize = serial.EIGHTBITS
    serialPort.stopbits = serial.STOPBITS_ONE
    serialPort.parity = serial.PARITY_NONE
    print "Initialised DepthTransducer serial."
    serialPort.flushInput()
    serialPort.flushOutput()
    return serialPort.isOpen()
    
################################################################
def listenForData(status):
    global serialPort
    global pitch_callback
    
    pitch_callback = 0.
    
    controlRate = 10. # [Hz]
    controlPeriod = 1/controlRate
    r = rospy.Rate(controlRate)
    rate_ok = True
    #### FILTER INFO ####
    depth_array_length = 20
    Dx = numpy.zeros([depth_array_length],float) # time vector for PT filtering
    Dy = numpy.zeros([depth_array_length],float) # depth vector for PT filtering
    for i in range(0,depth_array_length): 
        Dx[i] = i
    
    oceanserver_pitch_array_length = 10
    Px = numpy.zeros([pitch_array_length],float)
    Py = numpy.zeros([pitch_array_length],float)
    for i in range(0,pitch_array_length): 
        Px[i] = i
        
    depth_old = 0.0
    

    
    #####################
    
    # to control a timing for status publishing
    timeZero_status = time.time()
    dt_status = rospy.get_param('status_timing')
    depth_glitch_delta = rospy.get_param('depth/GlitchDelta')

    depth_base = None # for calibrating the depth sensor: ensuring zero depth when launch at surface
    
    while not rospy.is_shutdown():    
        timeRef = time.time()
        previous_depth = 0  # for removing glitches, compare current sensor read to previous
        try:
            # time.sleep(0.01)  # Prevents node from using 100% CPU!!
            while serialPort.inWaiting() > 0 and serialPort.read(1) == '$':     #while there is data to be read - read the line...
                # to control a timing for status publishing
                if time.time()-timeZero_status > dt_status:
                    timeZero_status = time.time()
                    pubStatus.publish(nodeID = 5, status = True)
                
                pubStatus.publish(nodeID = 5, status = status)
                
                #data_raw = serialPort.readline(size = None, eol = '\n')
                data_raw = serialPort.readline()
                                
                data = numpy.array((findall('[-]*\d+.\d+',data_raw)), numpy.float)

                try:
                    if depth_base == None:
                        #Convert ADC value to depth value: the last term is for calibration
                        depth_base = (data[4]*42.045) - 0.15 # assume that the auv is already submerge by 0.15m
                        depth_read = 0
                    else:
                        #Convert ADC value to depth value: the last term is for calibration
                        depth_read = (data[4]*42.045) - depth_base

                    # check if a glitch to a too large value happened
                    # only a step *up* to a *larger* depth value will be detected
                    if (depth_read - previous_depth) > depth_glitch_delta:
                        depth = previous_depth
                    else:
                        depth = depth_read
                    previous_depth = depth_read  # use read value, in case of actual change it will be used next time
                    depth_calib = depth - L_shift*math.sin(pitch_callback*math.pi/180.)# depth that takes into account the pitch angle of the AUV

                try:
                    pitch_raw   = data[2]
                    pitch       = pitch_raw-180
                    if pitch <-180:
                        pitch=pitch%360
                    #pitch = pitch_raw
                    
                    roll_raw    = data[1]    
                    roll        =-roll_raw     
                    
                    #roll = roll_raw
                              
                    temperature = data[3]          
                                        
                    m           = data[5]
                    mx          = data[7]
                    my          =-data[6]  
                    mz          =-data[8]  
                    
                    mx_raw      = data[6]
                    my_raw      = data[7]
                    mz_raw      = data[8]
                    
                    mx = mx_raw
                    my = my_raw
                    mz = mz_raw

                    heading     = calibrate(mx_raw,my_raw,mz_raw, pitch_raw, roll_raw)
                    
                    a           = data[9]
                    ax          = data[11]
                    ay          =-data[10]
                    az          =-data[12]
                                        
                    #### DEPTH FILTER ####
                    if rateOK:
                        T = controlPeriod
                    else:
                        T = timeElapse
                    Dx_real = Dx * T
                    
                    Dy[1:depth_array_length] = Dy[0:(depth_array_length-1)]
                    Dy[0] = depth_calib
                    [der, depth_filt] = numpy.polyfit(Dx_real, Dy, 1)
                    depth_der = -der
                    #depth_filt = depth
                                      
                    #### PITCH FILTER ####
                    Px_real = Px * dt
                    Py[1:pitch_array_length] = Py[0:(pitch_array_length-1)]
                    Py[0] = pitch
                    [der, pitch_filt] = numpy.polyfit(Px_real, Py, 1)
                    pitch_der = -der
                                        
                    print '*******'
                    print 'heading %f' %(heading)
#                    print 'pitch %f' %(pitch)                    
                    print 'pitch (filtered) %f' %(pitch)
#                    print 'pitch_der (filtered) %f' %(pitch_der)
                    print 'roll %f' %(roll)
                    print 'temperature %f' %(temperature)
#                    print 'depth %f' %(depth)
                    print 'depth (filtered) %f' %(depth)
#                    print 'depth_der (filtered) %f' %(depth_der)
#                    print 'm %f' %(m)
#                    print 'mx %f' %(mx)
#                    print 'my %f' %(my)
#                    print 'mz %f' %(mz)
#                    print 'a %f' %(a)
#                    print 'ax %f' %(ax)
#                    print 'ay %f' %(ay)
#                    print 'az %f' %(az)
     
                    #Publish data to compass_out
                    pub.publish(heading=heading,pitch=pitch,roll=roll,temperature=temperature,depth=depth,m=m,mx=mx,my=my,mz=mz,a=a,ax=ax,ay=ay,az=az,depth_filt=depth_filt,depth_der=depth_der,pitch_filt=pitch_filt,pitch_der=pitch_der)
                    depth_msg.depth = depth_read   # the depth that is directly determined from a static pressure.
                    depth_msg.depth_calib = depth_calib   # the depth with filtered glitches and pitch angle correction
                    depth_msg.depth_filt = depth_filt   # depth_calib that is filtered by PT-filter.
                    depth_msg.depth_der = depth_der   # derivative of depth_calib: a by-product of the PT-filter.
                    
                    #Publish data
                    pub.publish(depth_msg)
                  
                except ValueError: 
                    print 'not a float'
                
        except:
            print 'read error'
        
        timeElapse = time.time()-timeRef
        if timeElapse < controlPeriod:
            rateOK = True
            r.sleep()
        else:
            rateOK = False
            str = "depth_transducer rate does not meet the desired value of %.2fHz: actual control rate is %.2fHz" %(controlRate,1/timeElapse) 
            rospy.logwarn(str)
            pubMissionLog.publish(str)

def compass_callback(data):
    global pitch_callback
    pitch_callback = data.pitch # pitch angle measured by xsens

def calibrate(mx,my,mz, pitch, roll):

    pitch = numpy.radians(roll)
    roll  = numpy.radians(pitch)

        
    U = numpy.matrix([[0.00583711864398940, 0.000619779486949836, 9.27558703674774e-06],[0, 0.00478543996712305, -2.33933064978229e-06],[0, 0, 6.05590876286348e-05]])
    
    c = numpy.matrix([[-51.8129873735954],[-27.4232376953900],[13686.8142270094]])

    
    v = numpy.matrix([[mx],[my],[mz]])
    
    w = numpy.dot(U,(v - c))  #Normalised m terms
    
    eqn22_topline = (w[2]*numpy.sin(roll) - w[1]*numpy.cos(roll))
    
    eqn22_botline = (w[0]*numpy.cos(pitch) + w[1]*numpy.sin(pitch)*numpy.sin(roll) + w[2]*numpy.sin(pitch)*numpy.cos(roll))
    
    heading2 = math.atan2(eqn22_topline,eqn22_botline)*180/numpy.pi
    
    heading3 = (-heading2 + 90)%360
    
    
    return heading3
    
    
################################################################

def validDataCheck():

    attempts = 1
    
    while attempts < 5:
        
        while not serialPort.read(1) == '$':
            pass
        #The following line has been left for clarity of the change required with new Python versions
        #dataRaw = serialPort.readline(size = None, eol = '\n')   #This line MUST be left commented!
        #The following line contains the actual change required with Python v2.6+; the command reads in line of the data
        dataRaw = serialPort.readline()  #serialIO.readline()
        #dataRaw = serialPort.readline(size = None, eol = '\n')		#Read in line of data
        data = findall('[-]*\d+.\d+',dataRaw)
        print data
        if len(data) == 13:
            return True
    
    return False
    
################################################################
def shutdown():
    serialPort.flushInput()
    serialPort.flushOutput()
    pubStatus.publish(nodeID = 5, status = False)
    serialPort.close()

################################################################        
#     INITIALISE     ###########################################
################################################################

if __name__ == '__main__':
    time.sleep(1) #Allow System to come Online    
    rospy.init_node('OceanServer_compass')
    
    global pub
    global serialPort
    global depth_msg
    depth_msg = depth()
    
    pub = rospy.Publisher('depth_out', depth)
    pubMissionLog = rospy.Publisher('MissionStrings', String)
    rospy.Subscriber('compass_out', compass, compass_callback) 
    pubStatus = rospy.Publisher('status', status)
    
    rospy.on_shutdown(shutdown)
    
    port_status = setUpSerial()
    log_str = "OceanServer port status = %s. Port = %s" %(port_status, serialPort.portstr)
    rospy.loginfo(log_str)
    time.sleep(0.3)
    string_status=validDataCheck()
    
    if (port_status and string_status) == True:    
        status = True
        pubStatus.publish(nodeID = 5, status = status)
        rospy.loginfo("OceanServer compass online")
        rospy.loginfo("Depth transducer online")
    else:
        status = False
        pubStatus.publish(nodeID = 5, status = status)
    
    listenForData(status)   #Main loop for receiving data
